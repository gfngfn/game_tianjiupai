import Logger
import Models
import Room

module UserServer :> sig
  open Stdlib
  open Models

  type info :: o

  type proc :: o

  type user_state = {
    user_name  : user_name,
    belongs_to : option<room_id>,
  }

  type websocket_proc = pid<RawValue.t>
    /* For external use; corresponds to `pid()` */

  val start_link<$a> : fun(user_id, binary) -> [$a]result<proc, GenServer.start_link_error>

  val get_user_state<$a> : fun(user_id) -> [$a]option<user_state>

  val get_name<$a> : fun(user_id) -> [$a]option<binary>

  val exists<$a> : fun(user_id) -> [$a]bool

  val get_room<$a> : fun(user_id) -> [$a]option<room_id>

  val set_room<$a> : fun(user_id, option<room_id>) -> [$a]option<unit>

  val as_pid : fun(proc) -> pid<info>

  val from_pid : fun(pid<info>) -> proc

  val set_websocket_connection<$a> : fun(user_id, websocket_proc) -> [$a]option<unit>

  val get_proc<$a> : fun(user_id) -> [$a]option<proc>

end = struct
  open Stdlib
  open Models

  type websocket_proc = pid<RawValue.t>

  type user_state = {
    user_name  : user_name,
    belongs_to : option<room_id>,
  }

  module Callback = struct

    type init_arg = {user_id, binary}

    type settings = {
      user_id   : user_id,
      user_name : binary,
    }

    type state = {
      settings             : settings,
      belongs_to           : option<{room_id, MonitorRef.t}>,
      websocket_connection : option<MonitorRef.t>,
    }

    type request =
      | SetRoom(option<room_id>)
      | SetWebsocketConnection(websocket_proc)
      | GetUserState

    type response =
      | RoomSet(bool)
      | WebsocketConnectionSet
      | UserStateGot(user_state)

    type cast_message =
      | DummyCastMessage

    type info = RawValue.t

    type global = user_id

    val init(init_arg) = act
      let {user_id, user_name} = init_arg in
      let settings = { user_id = user_id, user_name = user_name } in
      let state =
        {
          settings             = settings,
          belongs_to           = None,
          websocket_connection = None,
        }
      in
      GenServer.init_ok(state)

    val monitor_room<$a>(room_id) : [$a]option<MonitorRef.t> = act
      Room.monitor(room_id)
/*
    val monitor<$a> : fun(websocket_proc) -> [$a]monitor_ref = external 1 ```
      monitor(WsProc) ->
          erlang:monitor(process, WsProc).
    ```

    val demonitor<$a> : fun(monitor_ref) -> [$a]unit = external 1 ```
      demonitor(MonitorRef) ->
          erlang:demonitor(MonitorRef).
    ```
*/
    val handle_call(req, _, state) = act
      case req of
      | GetUserState ->
          let belongs_to =
            Option.map(fun(pair) -> let {room_id, _} = pair in room_id end, state.belongs_to)
          in
          let user_state =
            {
              user_name  = state.settings.user_name,
              belongs_to = belongs_to,
            }
          in
          GenServer.reply(UserStateGot(user_state), state)
      | SetRoom(room_id_opt) ->
          case room_id_opt of
          | None ->
              do _ <-
                case state.belongs_to of
                | None                 -> return({})
                | Some({_, mref_room}) -> MonitorRef.demonitor(mref_room)
                end
              in
              let state = { state | belongs_to = None } in
              GenServer.reply(RoomSet(true), state)
          | Some(room_id) ->
              do monitor_ref_opt <- monitor_room(room_id) in
              case monitor_ref_opt of
              | None ->
                  GenServer.reply(RoomSet(false), state)
              | Some(monitor_ref_new) ->
                  do _ <-
                    case state.belongs_to of
                    | None                 -> return({})
                    | Some({_, mref_room}) -> MonitorRef.demonitor(mref_room)
                    end
                  in
                  let state = { state | belongs_to = Some({room_id, monitor_ref_new}) } in
                  GenServer.reply(RoomSet(true), state)
              end
          end
      | SetWebsocketConnection(ws_proc) ->
          do _ <-
            case state.websocket_connection of
            | None          -> return({})
            | Some(mref_ws) -> MonitorRef.demonitor(mref_ws)
            end
          in
          do monitor_ref_new <- MonitorRef.monitor(ws_proc) in
          let state = { state | websocket_connection = Some(monitor_ref_new) } in
          do _ <-
            case state.belongs_to of
            | None               -> return({})
            | Some({room_id, _}) -> Room.notify_connected(room_id, state.settings.user_id)
            end
          in
          GenServer.reply(WebsocketConnectionSet, state)
      end

    val handle_cast(msg, state) = act
      let _ = assert Logger.warning(f'unexpected cast message (message: ~p, state: ~p)', {msg, state}) in
      GenServer.no_reply(state)

    val is_room_down(mref, state : state) =
      case state.belongs_to of
      | None                 -> false
      | Some({_, mref_room}) -> MonitorRef.equal(mref, mref_room)
      end

    val is_websocket_down(mref, state) =
      case state.websocket_connection of
      | None          -> false
      | Some(mref_ws) -> MonitorRef.equal(mref, mref_ws)
      end

    val handle_timeout(state : state) = act
      GenServer.no_reply_and_stop(StopReason.normal(), state)

    val handle_down(mref, pid, reason, state : state) = act
      let user_id = state.settings.user_id in
      do state <-
        if is_room_down(mref, state) then
          let _ =
            assert Logger.info(
              f'room closed (user_id: ~s, reason: ~p)',
              {user_id, reason}
            )
          in
          return({ state | belongs_to = None })
        else if is_websocket_down(mref, state) then
          let _ =
            assert Logger.info(
              f'WebSocket connection closed (user_id: ~s, reason: ~p)',
              {user_id, reason}
            )
          in
          do _ <-
            case state.belongs_to of
            | None               -> return({})
            | Some({room_id, _}) -> Room.notify_disconnected(room_id, user_id)
            end
          in
          return({ state | websocket_connection = None })
        else
          let _ =
            assert Logger.warning(
              f'unexpected down (user_id: ~s, mref: ~p, pid: ~p, reason: ~p, state: ~p)',
              {user_id, mref, pid, reason, state}
            )
          in
          return(state)
      in
      GenServer.no_reply(state)

    val handle_info(info : RawValue.t, state : state) = act
          let _ = assert Logger.warning(f'unexpected info (info: ~p, state: ~p)', {info, state}) in
          GenServer.no_reply(state)

    val terminate(reason, state) = act
      let _ = assert Logger.info(f'terminate (reason: ~p, user_id: ~s)', {reason, state.settings.user_id}) in
      return({})
  end

  module Impl = GenServer.Make(Callback)

  type info = Callback.info

  type proc = Impl.proc

  val get_proc<$a>(user_id) : [$a]option<proc> = act
    Impl.where_is_global(user_id)

  val exists(user_id) = act
    do opt <- get_proc(user_id) in
    case opt of
    | None    -> return(false)
    | Some(_) -> return(true)
    end

  val start_link<$a>(user_id : user_id, user_name : binary) : [$a]result<proc, GenServer.start_link_error> = act
    Impl.start_link_name({user_id, user_name}, -name Global(user_id))

  val as_pid(proc) =
    Impl.as_pid(proc)

  val from_pid(pid) =
    Impl.from_pid(pid)

  val call<$a, $ret>(
    user_id : user_id,
    req     : Callback.request,
    f       : fun(Callback.response) -> [$a]option<$ret>
  ) : [$a]option<$ret> = act
    do proc_opt <- get_proc(user_id) in
    case proc_opt of
    | None ->
        return(None)
    | Some(proc) ->
        do resp_result <- Impl.call(proc, req) in
        case resp_result of
        | Ok(resp) ->
            f(resp)
        | Error(err) ->
            let _ =
              assert Logger.warning(
                f'call failed (user_id: ~s, req: ~p, proc: ~p, error: ~p)',
                {user_id, req, proc, err},
              )
            in
            return(None)
        end
    end

  val get_user_state(user_id) = act
    call(user_id, Callback.GetUserState,
      fun(Callback.UserStateGot(user_state)) -> act return(Some(user_state)) end)

  val get_name(user_id) = act
    do opt <- get_user_state(user_id) in
    return(Option.map(fun(u) -> u.user_name end, opt))

  val get_room(user_id) = act
    do opt <- get_user_state(user_id) in
    return(Option.bind(opt, fun(u) -> u.belongs_to end))

  val set_room(user_id, room_id_opt) = act
    call(user_id, Callback.SetRoom(room_id_opt), fun(Callback.RoomSet(success)) -> act
      if success then return(Some({})) else return(None)
    end)

  val set_websocket_connection(user_id, ws_proc) = act
    call(user_id, Callback.SetWebsocketConnection(ws_proc),
      fun(Callback.WebsocketConnectionSet) -> act return(Some({})) end)

end
