import Logger
import Models
import Room

module UserServer :> sig
  open Stdlib
  open Models

  type info :: o

  type proc :: o

  type user_state = {
    user_name  : user_name,
    belongs_to : option<room_id>,
  }

  type websocket_proc = RawValue.t
    /* For external use; corresponds to `pid()` */

  val start_link<$a> : fun(user_id, binary) -> [$a]result<proc, GenServer.start_link_error>

  val get_user_state<$a> : fun(user_id) -> [$a]option<user_state>

  val get_name<$a> : fun(user_id) -> [$a]option<binary>

  val exists<$a> : fun(user_id) -> [$a]bool

  val get_room<$a> : fun(user_id) -> [$a]option<room_id>

  val set_room<$a> : fun(user_id, option<room_id>) -> [$a]option<unit>

  val as_pid : fun(proc) -> pid<info>

  val from_pid : fun(pid<info>) -> proc

  val set_websocket_connection<$a> : fun(user_id, websocket_proc) -> [$a]option<unit>

  val get_proc<$a> : fun(user_id) -> [$a]option<proc>

end = struct
  open Stdlib
  open Models

  type websocket_proc = RawValue.t

  type user_state = {
    user_name  : user_name,
    belongs_to : option<room_id>,
  }

  module Callback = struct

    type init_arg = {user_id, binary}

    type monitor_ref = RawValue.t

    type settings = {
      user_id   : user_id,
      user_name : binary,
    }

    type state = {
      settings             : settings,
      belongs_to           : option<{room_id, monitor_ref}>,
      websocket_connection : option<monitor_ref>,
    }

    type request =
      | SetRoom(option<room_id>)
      | SetWebsocketConnection(websocket_proc)
      | GetUserState

    type response =
      | RoomSet(bool)
      | WebsocketConnectionSet
      | UserStateGot(user_state)

    type cast_message =
      | DummyCastMessage

    type info =
      RawValue.t

    type stop_reason =
      RawValue.t

    type global =
      user_id

    val init(init_arg) = act
      let {user_id, user_name} = init_arg in
      let settings = { user_id = user_id, user_name = user_name } in
      let state =
        {
          settings             = settings,
          belongs_to           = None,
          websocket_connection = None,
        }
      in
      GenServer.init_ok(state)

    val monitor_room<$a>(room_id) : [$a]option<monitor_ref> = act
      Room.monitor(room_id)

    val monitor<$a> : fun(websocket_proc) -> [$a]monitor_ref = external 1 ```
      monitor(WsProc) ->
          erlang:monitor(process, WsProc).
    ```

    val demonitor<$a> : fun(monitor_ref) -> [$a]unit = external 1 ```
      demonitor(MonitorRef) ->
          erlang:demonitor(MonitorRef).
    ```

    val handle_call(req, from, state) = act
      case req of
      | GetUserState ->
          let belongs_to =
            Option.map(fun(pair) -> let {room_id, _} = pair in room_id end, state.belongs_to)
          in
          let user_state =
            {
              user_name  = state.settings.user_name,
              belongs_to = belongs_to,
            }
          in
          GenServer.reply(UserStateGot(user_state), state)
      | SetRoom(room_id_opt) ->
          case room_id_opt of
          | None ->
              do dummy <-
                case state.belongs_to of
                | None                   -> return({})
                | Some({_, monitor_ref}) -> demonitor(monitor_ref)
                end
              in
              let state = { state | belongs_to = None } in
              GenServer.reply(RoomSet(true), state)
          | Some(room_id) ->
              do monitor_ref_opt <- monitor_room(room_id) in
              case monitor_ref_opt of
              | None ->
                  GenServer.reply(RoomSet(false), state)
              | Some(monitor_ref_new) ->
                  do dummy <-
                    case state.belongs_to of
                    | None                   -> return({})
                    | Some({_, monitor_ref}) -> demonitor(monitor_ref)
                    end
                  in
                  let state = { state | belongs_to = Some({room_id, monitor_ref_new}) } in
                  GenServer.reply(RoomSet(true), state)
              end
          end
      | SetWebsocketConnection(ws_proc) ->
          do dummy <-
            case state.websocket_connection of
            | None              -> return({})
            | Some(monitor_ref) -> demonitor(monitor_ref)
            end
          in
          do monitor_ref_new <- monitor(ws_proc) in
          let state = { state | websocket_connection = Some(monitor_ref_new) } in
          do dummy <-
            case state.belongs_to of
            | None               -> return({})
            | Some({room_id, _}) -> Room.notify_connected(room_id, state.settings.user_id)
            end
          in
          GenServer.reply(WebsocketConnectionSet, state)
      end

    val handle_cast(msg, state) = act
      let _ = assert Logger.warning(f'unexpected cast message (message: ~p, state: ~p)', {msg, state}) in
      GenServer.no_reply(state)

    val check_down_message : fun(info, monitor_ref) -> option<RawValue.t> = external 2 ```
      check_down_message(Info, MonitorRef) ->
        case Info of
            {'DOWN', MonitorRef, process, _Pid, Reason} -> {ok, Reason};
            _                                           -> error
        end.
    ```

    val check_room_down(info, state) =
      case state.belongs_to of
      | None                   -> None
      | Some({_, monitor_ref}) -> check_down_message(info, monitor_ref)
      end

    val check_websocket_down(info, state) =
      case state.websocket_connection of
      | None              -> None
      | Some(monitor_ref) -> check_down_message(info, monitor_ref)
      end

    val handle_info(info : RawValue.t, state : state) = act
      let user_id = state.settings.user_id in
      do state <-
        case check_room_down(info, state) of
        | Some(reason) ->
            let _ =
              assert Logger.info(
                f'room closed (user_id: ~s, reason: ~p)',
                {user_id, reason}
              )
            in
            return({ state | belongs_to = None })
        | None ->
            case check_websocket_down(info, state) of
            | Some(reason) ->
                let _ =
                  assert Logger.info(
                    f'WebSocket connection closed (user_id: ~s, reason: ~p)',
                    {user_id, reason}
                  )
                in
                do dummy <-
                  case state.belongs_to of
                  | None               -> return({})
                  | Some({room_id, _}) -> Room.notify_disconnected(room_id, user_id)
                  end
                in
                return({ state | websocket_connection = None })
            | None ->
                let _ =
                  assert Logger.info(
                    f'unexpected info (user_id: ~s, message: ~p)',
                    {user_id, info}
                  )
                in
                return(state)
            end
        end
      in
      GenServer.no_reply(state)

    val terminate(state) = act
      let _ = assert Logger.info(f'terminate (user_id: ~s)', {state.settings.user_id}) in
      return({})
  end

  module Impl = GenServer.Make(Callback)

  type info = Callback.info

  type proc = Impl.proc

  val get_proc<$a>(user_id) : [$a]option<proc> = act
    Impl.where_is_global(user_id)

  val exists(user_id) = act
    do opt <- get_proc(user_id) in
    case opt of
    | None    -> return(false)
    | Some(_) -> return(true)
    end

  val start_link<$a>(user_id : user_id, user_name : binary) : [$a]result<proc, GenServer.start_link_error> = act
    Impl.start_link_name({user_id, user_name}, -name Global(user_id))

  val as_pid(proc) =
    Impl.as_pid(proc)

  val from_pid(pid) =
    Impl.from_pid(pid)

  val call<$a, $ret>(
    user_id : user_id,
    req     : Callback.request,
    f       : fun(Callback.response) -> [$a]option<$ret>
  ) : [$a]option<$ret> = act
    do proc_opt <- get_proc(user_id) in
    case proc_opt of
    | None ->
        return(None)
    | Some(proc) ->
        do resp <- Impl.call(proc, req) in
        f(resp)
    end

  val get_user_state(user_id) = act
    call(user_id, Callback.GetUserState, fun(resp) -> act
      case resp of
      | Callback.UserStateGot(user_state) -> return(Some(user_state))
      end
    end)

  val get_name(user_id) = act
    do opt <- get_user_state(user_id) in
    return(Option.map(fun(u) -> u.user_name end, opt))

  val get_room(user_id) = act
    do opt <- get_user_state(user_id) in
    return(Option.bind(opt, fun(u) -> u.belongs_to end))

  val set_room(user_id, room_id_opt) = act
    call(user_id, Callback.SetRoom(room_id_opt), fun(resp) -> act
      case resp of
      | Callback.RoomSet(true)  -> return(Some({}))
      | Callback.RoomSet(false) -> return(None)
      end
    end)

  val set_websocket_connection(user_id, ws_proc) = act
    call(user_id, Callback.SetWebsocketConnection(ws_proc), fun(resp) -> act
      case resp of
      | Callback.WebsocketConnectionSet -> return(Some({}))
      end
    end)

end
