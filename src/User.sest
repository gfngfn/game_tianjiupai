import Logger
import Models
import UserServerSup
import UserServer
import Room

module User :> sig
  open Stdlib
  open Models

  val create<$a> : fun(binary) -> [$a]result<user_id, GenServer.start_link_error>

  val exists<$a> : fun(user_id) -> [$a]bool

  val delete<$a> : fun(user_id) -> [$a]unit

  val get_name<$a> : fun(user_id) -> [$a]option<binary>

  val get_info<$a> : fun(user_id) -> [$a]option<UserServer.user_state>

  val set_room<$a> : fun(user_id, option<room_id>) -> [$a]option<unit>

  val get_room<$a> : fun(user_id) -> [$a]option<room_id>

  val send_chat<$a> : fun(user_id, binary) -> [$a]option<unit>

  val ack<$a> : fun(user_id, snapshot_id) -> [$a]unit

  val require_next_inning<$a> : fun(user_id, snapshot_id) -> [$a]unit

  val set_websocket_connection<$a> : fun(user_id, RawValue.t) -> [$a]option<unit>

end = struct
  open Stdlib
  open Models

  val generate_user_id<$a> : fun() -> [$a]user_id = external 0 ```
    generate_user_id() ->
        Uuid = uuid:get_v4(),
        list_to_binary(uuid:uuid_to_string(Uuid)).
  ```

  val create(user_name) = act
    do user_id <- generate_user_id() in
    do res <- UserServerSup.start_child(-user_id user_id, -user_name user_name) in
    return(Result.map(fun(_) -> user_id end, res))

  val exists(user_id) = act
    UserServer.exists(user_id)

  val delete(user_id) = act
    do proc_opt <- UserServer.get_proc(user_id) in
    case proc_opt of
    | None ->
        return({})

    | Some(proc) ->
        do res <- UserServerSup.terminate_child(proc) in
        let _ =
          assert Logger.info(
            f'user deleted (user_id: ~s, result: ~p)',
            {user_id, res}
          )
        in
        return({})
    end

  val get_name(user_id) = act
    UserServer.get_name(user_id)

  val get_info(user_id) = act
    UserServer.get_user_state(user_id)

  val set_room(user_id, room_id_opt) = act
    UserServer.set_room(user_id, room_id_opt)

  val get_room(user_id) = act
    UserServer.get_room(user_id)

  val send_chat(user_id, text) = act
    do user_state_opt <- get_info(user_id) in
    case user_state_opt of
    | None ->
        return(None)

    | Some(user_state) ->
        case user_state.belongs_to of
        | None ->
            return(None)

        | Some(room_id) ->
            let user = { user_id = user_id, user_name = user_state.user_name } in
            Room.send_chat(room_id, user, text)
        end
    end

  val ack(user_id, snapshot_id) = act
    do opt <- get_room(user_id) in
    case opt of
    | None          -> return({})
    | Some(room_id) -> Room.ack(room_id, user_id, snapshot_id)
    end

  val require_next_inning(user_id, snapshot_id) = act
    do opt <- get_room(user_id) in
    case opt of
    | None          -> return({})
    | Some(room_id) -> Room.require_next_inning(room_id, user_id, snapshot_id)
    end

  val set_websocket_connection(user_id, ws_pid) = act
    UserServer.set_websocket_connection(user_id, ws_pid)
end
