import Logger
import Models
import UserServerSup
import UserServer
import WebSocketHandler

module User :> sig
  open Stdlib
  open Models

  val create<$a> : fun(binary) -> [$a]result<user_id, GenServer.start_link_error>

  val exists<$a> : fun(user_id) -> [$a]bool

  val delete<$a> : fun(user_id) -> [$a]bool

  val get_name<$a> : fun(user_id) -> [$a]option<binary>

  val get_info<$a> : fun(user_id) -> [$a]option<UserServer.user_state>

  val set_room<$a> : fun(user_id, option<room_id>) -> [$a]option<unit>

  val get_room<$a> : fun(user_id) -> [$a]option<room_id>

end = struct
  open Stdlib
  open Models

  val generate_user_id<$a> : fun() -> [$a]user_id = external 0 ```
    generate_user_id() ->
        Uuid = uuid:get_v4(),
        list_to_binary(uuid:uuid_to_string(Uuid)).
  ```

  val create(user_name) = act
    do user_id <- generate_user_id() in
    do res <- UserServerSup.start_child(-user_id user_id, -user_name user_name) in
    return(Result.map(fun(_) -> user_id end, res))

  val exists(user_id) = act
    UserServer.exists(user_id)

  val delete(user_id) = act
    do proc_opt <- UserServer.get_proc(user_id) in
    case proc_opt of
    | None ->
        return(false)

    | Some(proc) ->
        do res <- UserServerSup.terminate_child(proc) in
        return(true)
    end

  val get_name(user_id) = act
    UserServer.get_name(user_id)

  val get_info(user_id) = act
    UserServer.get_user_state(user_id)

  val set_room(user_id, room_id_opt) = act
    UserServer.set_room(user_id, room_id_opt)

  val get_room(user_id) = act
    UserServer.get_room(user_id)

end
