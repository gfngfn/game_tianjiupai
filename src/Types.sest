import Models
import Quad
import SnapshotId
import Card

module Types = struct

  type room_id = Models.room_id

  type room_name = Models.room_name

  type user_id = Models.user_id

  type user_name = Models.user_name

  type user = Models.user

  type snapshot_id = Models.snapshot_id

  type whole_room_state = Models.room_summary

  type game_player = Models.game_player

  type closed_or<$a> = Models.closed_or<$a>

  type big_with_design = Models.big_with_design

  type exposed<$a> = Models.exposed<$a>

  type table_state = Models.table

  type log = Models.log

  type user_state = {
    user_name  : user_name,
    belongs_to : option<room_id>,
  }

  type game_meta = {
    inning_index     : int,
    num_consecutives : int,
    parent_seat      : Quad.seat,
    players          : Quad.t<game_player>
  }

  type observable_inning_state = {
    starts_at : Quad.seat,
    your_hand : list<Card.t>,
    gains     : Quad.t<list<Card.t>>,
    table     : table_state
  }

  type observable_inning =
    | ObservableDuringInning(observable_inning_state)
    | ObservableInningEnd(Quad.t<list<Card.t>>)

  type observable_game_state = {
    meta              : game_meta,
    observable_inning : observable_inning,
    synchronizing     : bool,
    snapshot_id       : snapshot_id,
  }

  type submission = {
    seat       : Quad.seat,
    submitted  : list<option<Card.t>>,
    new_state  : observable_game_state,
    trick_last : option<table_state>,
  }

  type notification =
    | NotifyComment(user, binary)
    | NotifyEntered(user)
    | NotifyExited(user)
    | NotifyGameStart(observable_game_state)
    | NotifyNextStep
    | NotifySubmission(submission)

  type observable_room_state =
    | Waiting(list<user>)
    | Playing(observable_game_state)

  type personal_room_state = {
    room_id    : room_id,
    room_name  : room_name,
    logs       : list<log>,
    observable : observable_room_state,
  }

end
