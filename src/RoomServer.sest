import Logger
import Models
import Quad
import Card
import SnapshotId
import Inning
import WebSocketHandler

module RoomServer :> sig
  open Stdlib
  open Models

  type info :: o

  type proc :: o

  val start_link<$a> : fun(room_id, binary) -> [$a]result<proc, GenServer.start_link_error>
  val as_pid : fun(proc) -> pid<info>
  val from_pid : fun(pid<info>) -> proc
  val monitor<$a> : fun(room_id) -> [$a]option<MonitorRef.t>

  val get_whole_state<$a> : fun(room_id) -> [$a]option<room_summary>
  val get_whole_state_by_proc<$a> : fun(proc) -> [$a]option<room_summary>

  #[doc(```
    `get_personal_state(room_id, user_id)` returns
    how the current state of the room `room_id` can be seen from the user `user_id`
    if `user_id` is a member of `room_id`, or returns `None` otherwise.
  ```)]
  val get_personal_state<$a> : fun(room_id, user_id) -> [$a]option<personal_state>

  #[doc(```
    `send_chat(room_id, from, text)` posts the chat message `text` written by the user `from`
    to the room `room_id` and thereby notifies the other members in the room about the post.
  ```)]
  val send_chat<$a> : fun(room_id, user, binary) -> [$a]option<unit>

  #[doc(```
    `attend(room_id, user, ws_proc)` allows `user` to attend the room `room_id` if possible,
    or rejects the attendance otherwise (due to no seat available or the non-existence of `room_id`).
  ```)]
  val attend<$a> : fun(room_id, user, WebSocketHandler.proc) -> [$a]option<personal_state>

  #[doc(```
    `exit(room_id, user_id)` lets `user` exit the room `room_id`.
  ```)]
  val exit<$a> : fun(room_id, user_id) -> [$a]option<unit>

  #[doc(```
    `submit(room_id, user_id, cards)` attempts to submit cards from the user `user_id`
    to the table of the room `room_id`.
    If the attempt succeeds, it returns the new state updated by the submission seen from the submitter.
    It fails when:

    * `room_id` does not exist,
    * `user_id` is not a member of `room_id`, or
    * the list `cards` is not a valid submission
      (e.g. because there exists a card in `cards` that is not owned by `user_id`, or
      `cards` is not a valid composition according to the rule).
  ```)]
  val submit<$a> : fun(room_id, user_id, list<Card.t>) -> [$a]option<{observable_game_state, option<last>}>

  #[doc(```
    `ack(room_id, user_id, snapshot_id)` tells the room `room_id` that `user_id` returned ACK
    and that thereby the synchronization between `user_id` and the server has been established.
  ```)]
  val ack<$a> : fun(room_id, user_id, snapshot_id) -> [$a]unit

  val require_next_inning<$a> : fun(room_id, user_id, snapshot_id) -> [$a]unit

  val set_connection<$a> : fun(room_id, user_id, WebSocketHandler.proc) -> [$a]unit

end = struct
  open Stdlib
  open Models

  val disconnection_timeout() =
    30000

  val maximum_num_innings() =
    8

  type settings = {
    room_id   : room_id,
    room_name : binary,
  }

  type connection =
    | Connected(WebSocketHandler.proc, MonitorRef.t)
    | Disconnected(Timer.t)

  type internal_player = {
    user       : user,
    connection : connection,
  }

  type waiting_state = {
    members : list<internal_player>,
  }

  type sync =
    | WaitingInput
    | WaitingSync(Quad.t<bool>)

  type whole_inning =
    | DuringInning(Inning.t)
    | InningEnd(Quad.t<list<Card.t>>, Quad.t<bool>)

  type whole_game_meta =
    | Meta({
        inning_index     : int,
        num_consecutives : int,
        parent_seat      : Quad.seat,
        scores           : Quad.t<int>,
        players          : Quad.t<option<internal_player>>,
      })

  type whole_game_state = {
    meta        : whole_game_meta,
    inning      : whole_inning,
    snapshot_id : snapshot_id,
    sync        : sync, /* Tracks whether each player is ready for the next step. */
  }

  type internal_room_state =
    | InternalWaiting(waiting_state)
    | InternalPlaying(whole_game_state)

  module Callback = struct
    type init_arg = {room_id, binary}

    type request =
      | GetWholeState
      | GetPersonalState(user_id)
      | SendChat(user, binary)
      | Attend(user, WebSocketHandler.proc)
      | Exit(user_id)
      | Submit(user_id, list<Card.t>)

    type response =
      | WholeState(room_summary)
      | PersonalState(option<personal_state>)
      | ChatSent
      | Attended(option<personal_state>)
      | Exited(bool)
      | SubmissionDone(option<{observable_game_state, option<last>}>)

    type cast_message =
      | Ack(user_id, snapshot_id)
      | RequireNextInning(user_id, snapshot_id)
      | SetConnection(user_id, WebSocketHandler.proc)

    type info =
      | DisconnectionTimeout(user_id)

    val set_disconnection_timer(user_id : user_id, -log message) = act
      do res <-
        Timer.send_after_self(disconnection_timeout(), DisconnectionTimeout(user_id))
      in
      let _ =
        assert Logger.info(
          f'sets timer (~s, user_id: ~s, result: ~p)',
          {message, user_id, res}
        )
      in
      return(res)

    val cancel_disconnection_timer(timer : Timer.t, user_id : user_id, -log message) = act
      do res <- Timer.cancel(timer) in
      let _ =
        assert Logger.info(
          f'cancels timer (~s, user_id: ~s, timer: ~p, result: ~p)',
          {message, user_id, timer, res}
        )
      in
      return(res)

    type state = {
      settings      : settings,
      reversed_logs : list<log>,
      room_state    : internal_room_state,
    }

    type global = room_id

    val init(init_arg) = act
      let {room_id, room_name} = init_arg in
      let settings = {room_id = room_id, room_name = room_name} in
      GenServer.init_ok({
        settings      = settings,
        reversed_logs = [],
        room_state    = InternalWaiting({members = []})
      })

    val get_members_from_state(room_state : internal_room_state) : {bool, list<user>} =
      case room_state of
      | InternalWaiting(waiting_state) ->
          {false, List.map(fun(w) -> w.user end, waiting_state.members)}

      | InternalPlaying(whole_game_state) ->
          let Meta(meta) = whole_game_state.meta in
          let player_opts = Quad.to_list(meta.players) in
          let members =
            List.filter_map(
              fun(player_opt) ->
                case player_opt of
                | None         -> None
                | Some(player) -> Some(player.user)
                end
              end,
              player_opts)
          in
          {true, members}
      end

    val make_whole_room_state(state : state) : room_summary =
      let settings = state.settings in
      let {is_playing, members} = get_members_from_state(state.room_state) in
      {
        room       = { room_id = settings.room_id, room_name = settings.room_name },
        is_playing = is_playing,
        members    = members,
      }

    val find_user_seat(game_state : whole_game_state, user_id : user_id) : option<{Quad.seat, internal_player}> =
      let Meta(meta) = game_state.meta in
      let opt =
        Quad.find(
          fun(player_opt) ->
            case player_opt of
            | None         -> false
            | Some(player) -> Binary.equal(player.user.user_id, user_id)
            end
          end,
          meta.players)
      in
      Option.map(fun({seat, Some(player)}) -> {seat, player} end, opt)

    val get_connected_user_ids(game_state : whole_game_state, -except seat0 : Quad.seat) : list<user_id> =
      let Meta(meta) = game_state.meta in
      let {p_a, p_b, p_c, p_d} = Quad.decompose(meta.players) in
      let players = [{SeatA, p_a}, {SeatB, p_b}, {SeatC, p_c}, {SeatD, p_d}] in
      List.filter_map(
        fun({seat, player_opt}) ->
          if Quad.seat_equal(seat, seat0) then
            None
          else
            Option.bind(
              player_opt,
              fun(player) ->
                case player.connection of
                | Connected(_, _) -> Some(player.user.user_id)
                | Disconnected(_) -> None
                end
              end)
        end,
        players)

    val get_connected_user_ids_from_list(players : list<internal_player>, -except user_id : user_id) : list<user_id> =
      List.filter_map(
        fun(p) ->
          case p.connection of
          | Connected(_, _) ->
              let u = p.user.user_id in
              if Binary.equal(u, user_id) then None else Some(u)

          | Disconnected(_) ->
              None
          end
        end,
        players)

    val get_connected_user_ids_from_quad(players : Quad.t<option<internal_player>>, -except user_id : user_id) : list<user_id> =
      List.filter_map(
        fun(g_opt : option<internal_player>) ->
          case g_opt of
          | None ->
              None

          | Some(g) ->
              case g.connection of
              | Connected(_, _) ->
                  let u = g.user.user_id in
                  if Binary.equal(u, user_id) then None else Some(u)

              | Disconnected(_) ->
                  None
              end
          end
        end,
        Quad.to_list(players))

    val make_game_player(iplayer : internal_player) : game_player =
      let is_connected =
        case iplayer.connection of
        | Connected(_, _) -> true
        | Disconnected(_) -> false
        end
      in
      {
        user         = iplayer.user,
        is_connected = is_connected,
      }

    val make_game_meta(Meta(meta) : whole_game_meta) : game_meta =
      {
        inning_index     = meta.inning_index,
        num_consecutives = meta.num_consecutives,
        parent_seat      = meta.parent_seat,
        scores           = meta.scores,
        players          = Quad.map(fun(opt) -> Option.map(make_game_player, opt) end, meta.players),
      }

    val make_observable_game_state(game_state : whole_game_state, user_id : user_id) : option<observable_game_state> =
      case find_user_seat(game_state, user_id) of
      | None ->
          None

      | Some({seat, _}) ->
          let synchronizing =
            case game_state.sync of
            | WaitingInput   -> false
            | WaitingSync(_) -> true
            end
          in
          let observable_inning =
            case game_state.inning of
            | DuringInning(inning)     -> Models.ObservableDuringInning(Inning.observe(seat, inning))
            | InningEnd(gains_quad, _) -> Models.ObservableInningEnd(gains_quad)
            end
          in
          Some({
            meta              = make_game_meta(game_state.meta),
            observable_inning = observable_inning,
            synchronizing     = synchronizing,
            snapshot_id       = game_state.snapshot_id,
          })
      end

    val make_observable(room_state : internal_room_state, user_id : user_id) : option<observable_room_state> =
      case room_state of
      | InternalWaiting(waiting_state) ->
          let members = List.map(fun(w) -> w.user end, waiting_state.members) in
          Some(Models.WaitingStart(members))

      | InternalPlaying(game_state) ->
          Option.map(fun(obs) -> Models.PlayingGame(obs) end, make_observable_game_state(game_state, user_id))
      end

    val make_personal_state(state : state, user_id : user_id) : option<personal_state> =
      let settings = state.settings in
      case make_observable(state.room_state, user_id) of
      | None ->
          None

      | Some(observable) ->
          Some({
            room = { room_id = settings.room_id, room_name = settings.room_name },
            logs = List.reverse(state.reversed_logs),
            game = observable,
          })
      end

    val make_initial_sync() : Quad.t<bool> =
      Quad.make({false, false, false, false})

    val start_new_inning<$a>(Meta(meta) : whole_game_meta) : [$a]whole_game_state = act
      let next_parent_seat = meta.parent_seat in
      let inning = Inning.start(next_parent_seat) in
      do snapshot_id <- SnapshotId.generate() in
      return({
        meta        = Meta(meta),
        inning      = DuringInning(inning),
        snapshot_id = snapshot_id,
        sync        = WaitingSync(make_initial_sync()),
      })

    val notify(user_id, notifications) = act
      WebSocketHandler.notify(user_id, notifications)

    val notify_for_each<$a>(user_ids : list<user_id>, notifications : list<notification>) : [$a]unit = act
      List.for_each(fun(user_id) -> act notify(user_id, notifications) end, user_ids)

    val find_empty_seat(game_state : whole_game_state) : option<Quad.seat> =
      let Meta(meta) = game_state.meta in
      Option.map(
        fun(pair) -> let {seat, _} = pair in seat end,
        Quad.find(
          fun(player_opt) ->
            case player_opt of
            | Some(_) -> false
            | None    -> true
            end
          end,
          meta.players))

    val handle_send_chat(user : user, text : binary, state : state) = act
      let {_, members} = get_members_from_state(state.room_state) in
      let comment = { from = user, text = text } in
      do _ <-
        let user_ids = List.map(fun (u) -> u.user_id end, members) in
        notify_for_each(user_ids, [Models.NotifyComment(comment)])
      in
      GenServer.reply(ChatSent, { state | reversed_logs = Models.LogComment(comment) :: state.reversed_logs })

    val is_none(x) =
      case x of
      | None    -> true
      | Some(_) -> false
      end

    val handle_attend(user : user, ws_proc : WebSocketHandler.proc, state : state) = act
      let user_id = user.user_id in
      case state.room_state of
      | InternalPlaying(game_state0) ->
          case find_empty_seat(game_state0) of
          | None ->
              GenServer.reply(Attended(None), state)
          | Some(seat) ->
              let Meta(meta0) = game_state0.meta in
              do ws_mref <- WebSocketHandler.monitor(ws_proc) in
              let player = { user = user, connection = Connected(ws_proc, ws_mref) } in
              let players1 = Quad.update(seat, Some(player), meta0.players) in
              let game_state1 = { game_state0 | meta = Meta({ meta0 | players = players1 }) } in
              let user_ids_for_notification = get_connected_user_ids(game_state1, -except seat) in
              do game_state2 <-
                case game_state1.sync of
                | WaitingInput ->
                    let _ =
                      assert Logger.info(
                        f'attend -> waiting input (seat: ~p, user_id: ~s)',
                        {seat, user_id}
                      )
                    in
                    do _ <-
                      notify_for_each(user_ids_for_notification, [
                        Models.NotifyEnteredMidway({ user = user, seat = seat }),
                      ])
                    in
                    return(game_state1)

                | WaitingSync(sync_quad0) ->
                    if Quad.access(seat, sync_quad0) then
                      let _ =
                        assert Logger.info(
                          f'attend -> no need to sync (seat: ~p, user_id: ~s, sync_quad: ~p)',
                          {seat, user_id, sync_quad0}
                        )
                      in
                      do _ <-
                        notify_for_each(user_ids_for_notification, [
                          Models.NotifyEnteredMidway({ user = user, seat = seat }),
                        ])
                      in
                      return(game_state1)
                    else
                      let sync_quad1 = Quad.update(seat, true, sync_quad0) in
                      let _ =
                        assert Logger.info(
                          f'attend -> sync update (seat: ~p, user_id: ~s, sync_quad: ~p)',
                          {seat, user_id, sync_quad1}
                        )
                      in
                      case Quad.decompose(sync_quad1) of
                      | {true, true, true, true} ->
                          do _ <-
                            notify_for_each(user_ids_for_notification, [
                              Models.NotifyEnteredMidway({ user = user, seat = seat }),
                              Models.NotifyNextStep,
                            ])
                          in
                          return({ game_state1 | sync = WaitingInput })

                      | _ ->
                          do _ <-
                            notify_for_each(user_ids_for_notification, [
                              Models.NotifyEnteredMidway({ user = user, seat = seat }),
                            ])
                          in
                          return({ game_state1 | sync = WaitingSync(sync_quad1) })
                      end
                end
              in
              let state =
                { state |
                  room_state    = InternalPlaying(game_state2),
                  reversed_logs = Models.LogEntered(user) :: state.reversed_logs,
                }
              in
              let Some(personal_state) = make_personal_state(state, user_id) in
              GenServer.reply(Attended(Some(personal_state)), state)
          end

      | InternalWaiting(waiting_state) ->
          let members = waiting_state.members in
          if List.any(fun(w) -> Binary.equal(w.user.user_id, user_id) end, members) then
            let Some(personal_state) = make_personal_state(state, user_id) in
            GenServer.reply(Attended(Some(personal_state)), state)
          else
            do ws_mref <- WebSocketHandler.monitor(ws_proc) in
            let log_enter = Models.LogEntered(user) in
            let notif_enter = Models.NotifyEntered(user) in
            case members of
            | w0 :: w1 :: w2 :: _ ->
                let u0 = w0.user in
                let u1 = w1.user in
                let u2 = w2.user in
                let player_quad =
                  let player0 = { user = u0, connection = w0.connection } in
                  let player1 = { user = u1, connection = w1.connection } in
                  let player2 = { user = u2, connection = w2.connection } in
                  let player3 = { user = user, connection = Connected(ws_proc, ws_mref) } in
                  Quad.make({Some(player0), Some(player1), Some(player2), Some(player3)})
                in
                let parent_seat = Models.SeatA in
                let whole_game_meta =
                  Meta({
                    inning_index     = 0,
                    num_consecutives = 0, /* The initial value is exceptionally `0`, not `1` */
                    parent_seat      = parent_seat,
                    scores           = Quad.make({0, 0, 0, 0}),
                    players          = player_quad,
                  })
                in
                let game_index = { inning_index = 0, num_consecutives = 0 } in
                do game_state <- start_new_inning(whole_game_meta) in
                do _ <-
                  List.for_each(
                    fun(u) -> act
                      case make_observable_game_state(game_state, u) of
                      | None      -> return({})
                      | Some(obs) -> notify(u, [notif_enter, Models.NotifyGameStart(obs)])
                      end
                    end,
                    [u0.user_id, u1.user_id, u2.user_id]
                  )
                in
                let state =
                  { state |
                    room_state    = InternalPlaying(game_state),
                    reversed_logs = Models.LogGameStart(game_index) :: log_enter :: state.reversed_logs,
                  }
                in
                let Some(personal_state) = make_personal_state(state, user_id) in
                GenServer.reply(Attended(Some(personal_state)), state)

            | _ ->
                let w = { user = user, connection = Connected(ws_proc, ws_mref) } in
                let waiting_state = { waiting_state | members = List.append(members, [w]) } in
                do _ <- notify_for_each(List.map(fun(w) -> w.user.user_id end, members), [notif_enter]) in
                let state =
                  { state |
                    room_state    = InternalWaiting(waiting_state),
                    reversed_logs = log_enter :: state.reversed_logs,
                  }
                in
                let Some(personal_state) = make_personal_state(state, user_id) in
                GenServer.reply(Attended(Some(personal_state)), state)
            end
      end

    val handle_exit(user_id : user_id, state : state) = act
      let opt =
        case state.room_state of
        | InternalPlaying(game_state) ->
            case find_user_seat(game_state, user_id) of
            | None ->
                None

            | Some({seat, player}) ->
                let Meta(meta0) = game_state.meta in
                let players0 = meta0.players in
                let players1 = Quad.update(seat, None, players0) in
                let user_ids_for_notification = get_connected_user_ids(game_state, -except seat) in
                Some({
                  player.user,
                  user_ids_for_notification,
                  InternalPlaying({ game_state | meta = Meta({ meta0 | players = players1 }) })
                })
            end

        | InternalWaiting(waiting_state) ->
            let members0 = waiting_state.members in
            case List.filter(fun(w0) -> Binary.equal(w0.user.user_id, user_id) end, members0) of
            | [] ->
                None

            | w :: _ ->
                let members1 =
                  List.filter(
                    fun(w0) -> Bool.not(Binary.equal(w0.user.user_id, user_id)) end,
                    members0)
                in
                let user_ids_for_notification = List.map(fun(w) -> w.user.user_id end, members1) in
                Some({
                  w.user,
                  user_ids_for_notification,
                  InternalWaiting({ waiting_state | members = members1 })
                })
            end
        end
        in
        case opt of
        | None ->
            GenServer.reply(Exited(false), state)

        | Some({user, user_ids_for_notification, room_state}) ->
            do _ <-
              notify_for_each(user_ids_for_notification, [Models.NotifyExited(user)])
            in
            let state =
              { state |
                room_state    = room_state,
                reversed_logs = Models.LogExited(user) :: state.reversed_logs,
              }
            in
            GenServer.reply(Exited(true), state)
        end

    val make_winner_diff(losers : list<{Quad.seat, int}>) : int =
      let loser_diff_sum =
        List.foldl(
          fun(acc, loser) -> let {_, loser_diff} = loser in acc + loser_diff end,
          0,
          losers)
      in
      0 - loser_diff_sum

    val update_score(scores : Quad.t<int>, updates : list<{Quad.seat, int}>) : {Quad.t<int>, Quad.t<int>} =
      List.foldl(
        fun(acc, update) ->
          let {scores, diffs} = acc in
          let {seat, diff} = update in
          let score = Quad.access(seat, scores) in
          {
            Quad.update(seat, score + diff, scores),
            Quad.update(seat, diff, diffs)
          }
        end,
        {scores, Quad.make({0, 0, 0, 0})},
        updates)

    val deal_with_trick_end(
      Meta(meta)  : whole_game_meta,
      winner_seat : Quad.seat,
      special_opt : option<special_trick_end>,
    ) : {whole_game_meta, option<Quad.t<int>>} =
      case special_opt of
      | None ->
          {Meta(meta), None}
      | Some(_) ->
          let loser_seats = Quad.the_other_seats(winner_seat) in
          let num_consecutives = meta.num_consecutives in
          let parent_seat = meta.parent_seat in
          let losers =
            if Quad.seat_equal(winner_seat, parent_seat) then
            /* If the parent wins the trick: */
              List.map(
                fun(loser_seat) ->
                  let loser_diff = 0 - 2 * (num_consecutives + 1) in
                  {loser_seat, loser_diff}
                end,
                loser_seats)
            else
              List.map(
                fun(loser_seat) ->
                  let loser_diff =
                    if Quad.seat_equal(loser_seat, parent_seat) then
                      0 - 2 * (num_consecutives + 1)
                    else
                      0 - 2
                  in
                  {loser_seat, loser_diff}
                end,
                loser_seats)
          in
          let winner_diff = make_winner_diff(losers) in
          let {scores, diffs} = update_score(meta.scores, {winner_seat, winner_diff} :: losers) in
          {Meta({ meta | scores = scores }), Some(diffs)}
      end

    val make_loser_updates_when_parent_wins(
      num_consecutives : int,
      loser_seats      : list<Quad.seat>,
      gains_quad       : Quad.t<list<Card.t>>,
      coeff            : int,
    ) : list<{Quad.seat, int}> =
      List.map(
        fun(loser_seat) ->
          let num_gains = List.length(Quad.access(loser_seat, gains_quad)) in
          let loser_diff =
            if num_gains == 0 then
              0 - 5 * (num_consecutives + 1) * coeff
            else
              (num_gains - 4) * (num_consecutives + 1) * coeff
          in
          {loser_seat, loser_diff}
        end,
        loser_seats)

    val make_loser_updates_when_child_wins(
      num_consecutives : int,
      loser_seats      : list<Quad.seat>,
      parent_seat      : Quad.seat,
      gains_quad       : Quad.t<list<Card.t>>,
      coeff_original   : int,
    ) : list<{Quad.seat, int}> =
      List.map(
        fun(loser_seat) ->
          let num_gains = List.length(Quad.access(loser_seat, gains_quad)) in
          let loser_diff =
            let coeff =
              if Quad.seat_equal(loser_seat, parent_seat) then
                (num_consecutives + 1) * coeff_original
              else
                coeff_original
            in
            if num_gains == 0 then
              0 - 5 * coeff
            else
              (num_gains - 4) * coeff
          in
          {loser_seat, loser_diff}
        end,
        loser_seats)

    val deal_with_inning_end(
      Meta(meta)  : whole_game_meta,
      winner_seat : Quad.seat,
      special_opt : option<special_inning_end>,
      gains_quad  : Quad.t<list<Card.t>>,
    ) : {whole_game_meta, Quad.t<int>} =
      let loser_seats = Quad.the_other_seats(winner_seat) in
      let num_consecutives = meta.num_consecutives in
      let parent_seat = meta.parent_seat in
      if Quad.seat_equal(winner_seat, parent_seat) then
      /* If the parent wins the inning: */
        let losers =
          case special_opt of
          | Some(InningEndWithBazhijie) ->
              List.map(
                fun(loser_seat) ->
                  let loser_diff = (0 - 20) * (num_consecutives + 1) in
                  {loser_seat, loser_diff}
                end,
                loser_seats)

          | Some(InningEndWithQizhijie) ->
              List.map(
                fun(loser_seat) ->
                  let loser_diff = (0 - 10) * (num_consecutives + 1) in
                  {loser_seat, loser_diff}
                end,
                loser_seats)

          | Some(_) ->
            /* 至尊・四大賀・么結 */
              make_loser_updates_when_parent_wins(num_consecutives, loser_seats, gains_quad, 2)

          | None ->
              make_loser_updates_when_parent_wins(num_consecutives, loser_seats, gains_quad, 1)
          end
        in
        let winner_diff = make_winner_diff(losers) in
        let {scores, diffs} = update_score(meta.scores, {winner_seat, winner_diff} :: losers) in
        {
          Meta({
            inning_index     = meta.inning_index,
            num_consecutives = num_consecutives + 1,
            parent_seat      = parent_seat,
            scores           = scores,
            players          = meta.players,
          }),
          diffs
        }
      else
        let losers =
          case special_opt of
          | Some(InningEndWithBazhijie) ->
              List.map(
                fun(loser_seat) ->
                  let coeff =
                    if Quad.seat_equal(loser_seat, parent_seat) then
                      num_consecutives + 1
                    else
                      1
                  in
                  let loser_diff = 0 - 20 * coeff in
                  {loser_seat, loser_diff}
                end,
                loser_seats)

          | Some(InningEndWithQizhijie) ->
              List.map(
                fun(loser_seat) ->
                  let coeff =
                    if Quad.seat_equal(loser_seat, parent_seat) then
                      num_consecutives + 1
                    else
                      1
                  in
                  let loser_diff = 0 - 10 * coeff in
                  {loser_seat, loser_diff}
                end,
                loser_seats)

          | Some(_) ->
            /* 至尊・四大賀・么結 */
              make_loser_updates_when_child_wins(num_consecutives, loser_seats, parent_seat, gains_quad, 2)

          | None ->
              make_loser_updates_when_child_wins(num_consecutives, loser_seats, parent_seat, gains_quad, 1)
          end
        in
        let winner_diff = make_winner_diff(losers) in
        let {scores, diffs} = update_score(meta.scores, {winner_seat, winner_diff} :: losers) in
        {
          Meta({
            inning_index     = meta.inning_index + 1,
            num_consecutives = 1,
            parent_seat      = winner_seat,
            scores           = scores,
            players          = meta.players,
          }),
          diffs
        }

    val handle_submit_impl(user_id : user_id, cards : list<Card.t>, game_state : whole_game_state) = act
        case find_user_seat(game_state, user_id) of
        | None ->
            return(None)

        | Some({seat, _}) ->
            case game_state.inning of
            | InningEnd(_, _) ->
                return(None)

            | DuringInning(inning) ->
                case Inning.submit(seat, cards, inning) of
                | None ->
                    return(None)

                | Some({submit_result, is_front}) ->
                    do snapshot_id <- SnapshotId.generate() in
                    let whole_game_meta = game_state.meta in
                    let {game_state, last_opt} =
                      case submit_result of
                      | Inning.Continues(inning) ->
                          {
                            {
                              meta        = whole_game_meta,
                              inning      = DuringInning(inning),
                              snapshot_id = snapshot_id,
                              sync        = WaitingSync(make_initial_sync()),
                            },
                            None
                          }

                      | Inning.WinsTrick(winner_seat, last_table, submitter_hand, special_opt, inning) ->
                          let {whole_game_meta, diffs_opt} =
                            deal_with_trick_end(whole_game_meta, winner_seat, special_opt)
                          in
                          let changes_opt =
                            case {special_opt, diffs_opt} of
                            | {Some(special), Some(diffs)} ->
                                 Some({ change_reason = SpecialTrickEnd(special), diffs = diffs })
                            | _ ->
                                 None
                            end
                          in
                          {
                            {
                              meta        = whole_game_meta,
                              inning      = DuringInning(inning),
                              snapshot_id = snapshot_id,
                              sync        = WaitingSync(make_initial_sync()),
                            },
                            Some({table = last_table, hand = submitter_hand, changes = changes_opt})
                          }

                      | Inning.WinsInning(winner_seat, last_table, gains_quad, special_opt) ->
                          let {whole_game_meta, diffs} =
                            deal_with_inning_end(whole_game_meta, winner_seat, special_opt, gains_quad)
                          in
                          let reason =
                            case special_opt of
                            | None          -> NormalInningEnd
                            | Some(special) -> SpecialInningEnd(special)
                            end
                          in
                          let changes = { change_reason = reason, diffs = diffs } in
                          {
                            {
                              meta        = whole_game_meta,
                              inning      = InningEnd(gains_quad, make_initial_sync()),
                              snapshot_id = snapshot_id,
                              sync        = WaitingSync(make_initial_sync()),
                            },
                            Some({ table = last_table, hand = [], changes = Some(changes) })
                          }
                      end
                    in
                    let card_opts =
                      if is_front then
                        List.map(fun(card) -> Some(card) end, cards)
                      else
                        List.map(fun(_) -> None end, cards)
                    in
                    do _ <-
                      List.for_each(
                        fun(u) -> act
                          case make_observable_game_state(game_state, u) of
                          | None ->
                              return({})

                          | Some(obs) ->
                              let trick_last =
                                Option.map(
                                  fun(last) ->
                                    {
                                      table = last.table,
                                      changes = last.changes,
                                    }
                                  end,
                                  last_opt)
                              in
                              let submission =
                                {
                                  seat       = seat,
                                  submitted  = card_opts,
                                  new_state  = obs,
                                  trick_last = trick_last,
                                }
                              in
                              notify(u, [Models.NotifySubmission(submission)])
                          end
                        end,
                        get_connected_user_ids(game_state, -except seat)
                      )
                    in
                    let Some(obs) = make_observable_game_state(game_state, user_id) in
                    return(Some({obs, last_opt, game_state}))
                end
            end
      end

    val handle_submit(user_id : user_id, cards : list<Card.t>, state : state) = act
      do opt <-
        case state.room_state of
        | InternalWaiting(_) ->
            return(None)

        | InternalPlaying(game_state) ->
            case find_empty_seat(game_state) of
            | None    -> handle_submit_impl(user_id, cards, game_state)
            | Some(_) -> return(None)
            end
        end
      in
      case opt of
      | None ->
          GenServer.reply(SubmissionDone(None), state)

      | Some({obs, last_opt, game_state}) ->
          let reversed_logs =
            case last_opt of
            | None ->
                state.reversed_logs
            | Some(last) ->
                case last.changes of
                | None ->
                    state.reversed_logs
                | Some(changes) ->
                    Models.LogChanges(changes) :: state.reversed_logs
                end
            end
          in
          GenServer.reply(
            SubmissionDone(Some({obs, last_opt})),
            { state |
              room_state    = InternalPlaying(game_state),
              reversed_logs = reversed_logs,
            },
          )
      end

    val handle_ack(user_id : user_id, snapshot_id : snapshot_id, state : state) = act
      do opt <-
        case state.room_state of
        | InternalWaiting(_) ->
            return(None)

        | InternalPlaying(game_state) ->
            case find_user_seat(game_state, user_id) of
            | None ->
                return(None)

            | Some({seat, _}) ->
                if SnapshotId.equal(snapshot_id, game_state.snapshot_id) then
                  case game_state.sync of
                  | WaitingSync(sync_quad) ->
                      let sync_quad = Quad.update(seat, true, sync_quad) in
                      let _ =
                        assert Logger.info(
                          f'update sync (snapshot_id: ~s, user_id: ~s, quad: ~p)',
                          {snapshot_id, user_id, sync_quad}
                        )
                      in
                      case Quad.decompose(sync_quad) of
                      | {true, true, true, true} ->
                        /* If all the players are ready for the next step: */
                          let user_ids_for_notification = get_connected_user_ids(game_state, -except seat) in
                          do _ <- notify_for_each(user_id :: user_ids_for_notification, [Models.NotifyNextStep]) in
                          let game_state = { game_state | sync = WaitingInput } in
                          return(Some(game_state))

                      | _ ->
                          let game_state = { game_state | sync = WaitingSync(sync_quad) } in
                          return(Some(game_state))
                      end
                  | WaitingInput ->
                      let _ =
                        assert Logger.warning(
                          f'waiting input (snapshot_id: ~s, user_id: ~s)',
                          {snapshot_id, user_id}
                        )
                      in
                      return(None)
                  end
                else
                  let _ =
                    assert Logger.warning(
                      f'snapshot mismatch (got: ~s, expected: ~s, user_id: ~s)',
                      {snapshot_id, game_state.snapshot_id, user_id}
                    )
                  in
                  return(None)
            end
        end
      in
      case opt of
      | None             -> GenServer.no_reply(state)
      | Some(game_state) -> GenServer.no_reply({ state | room_state = InternalPlaying(game_state) })
      end

    type transition =
      | RoomTransitionToNextInning(whole_game_state, option<game_index>)
      | RoomClose

    val handle_require_next_inning(user_id : user_id, snapshot_id : snapshot_id, state : state) = act
      do opt <-
        case state.room_state of
        | InternalWaiting(_) ->
            return(None)

        | InternalPlaying(game_state) ->
            case find_user_seat(game_state, user_id) of
            | None ->
                return(None)

            | Some({seat, _}) ->
                if SnapshotId.equal(snapshot_id, game_state.snapshot_id) then
                  case game_state.inning of
                  | DuringInning(_) ->
                      return(None)

                  | InningEnd(gains_quad, inning_sync_quad) ->
                      let inning_sync_quad = Quad.update(seat, true, inning_sync_quad) in
                      let _ =
                        assert Logger.info(
                          f'update inning sync (snapshot_id: ~s, inning_sync_quad: ~p)',
                          {snapshot_id, inning_sync_quad}
                        )
                      in
                      case Quad.decompose(inning_sync_quad) of
                      | {true, true, true, true} ->
                        /* If all the players are ready for the next step: */
                          let whole_game_meta = game_state.meta in
                          let Meta(meta) = whole_game_meta in
                          let inning_index = meta.inning_index in
                          let user_ids_for_notification = get_connected_user_ids(game_state, -except seat) in
                          let user_ids_for_notification = user_id :: user_ids_for_notification in
                          if inning_index >= maximum_num_innings() then
                          /* If the last inning has ended: */
                            do _ <- notify_for_each(user_ids_for_notification, [Models.NotifyRoomClose]) in
                            return(Some(RoomClose))
                          else
                            do game_state <- start_new_inning(whole_game_meta) in
                            do _ <-
                              List.for_each(
                                fun(u) -> act
                                  case make_observable_game_state(game_state, u) of
                                  | None      -> return({})
                                  | Some(obs) -> notify(u, [Models.NotifyGameStart(obs)])
                                  end
                                end,
                                user_ids_for_notification)
                            in
                            let game_index =
                              let Meta(meta) = game_state.meta in
                              {
                                inning_index     = inning_index,
                                num_consecutives = meta.num_consecutives,
                              }
                            in
                            return(Some(RoomTransitionToNextInning(game_state, Some(game_index))))

                      | _ ->
                          let game_state = { game_state | inning = InningEnd(gains_quad, inning_sync_quad) } in
                          return(Some(RoomTransitionToNextInning(game_state, None)))
                      end
                  end
                else
                  return(None)
            end
        end
      in
      case opt of
      | None ->
          GenServer.no_reply(state)

      | Some(RoomClose) ->
          GenServer.no_reply_and_stop(StopReason.normal(), state)

      | Some(RoomTransitionToNextInning(game_state, game_index_opt)) ->
          let state =
            case game_index_opt of
            | None             -> state
            | Some(game_index) -> { state | reversed_logs = Models.LogGameStart(game_index) :: state.reversed_logs }
            end
          in
          GenServer.no_reply({ state | room_state = InternalPlaying(game_state) })
      end

    /* When the user of `user_id` re-connects to the server: */
    val handle_set_connection(user_id : user_id, ws_proc : WebSocketHandler.proc, state : state) = act
      do opt <-
        case state.room_state of
        | InternalWaiting(waiting_state) ->
            let members0 = waiting_state.members in
            case List.filter(fun(w) -> Binary.equal(w.user.user_id, user_id) end, members0) of
            | [] ->
                return(None)

            | w :: _ ->
                let user = w.user in
                do acc <-
                  List.foldl_effect(
                    fun(acc, w0) -> act
                      do w1 <-
                        if Binary.equal(w0.user.user_id, user_id) then
                          do Ok({}) <-
                            case w0.connection of
                            | Connected(_, _)     -> return(Ok({}))
                            | Disconnected(timer) -> cancel_disconnection_timer(timer, user_id, -log "waiting")
                            end
                          in
                          do ws_mref <- WebSocketHandler.monitor(ws_proc) in
                          return({ w0 | connection = Connected(ws_proc, ws_mref) })
                        else
                          return(w0)
                      in
                      return(w1 :: acc)
                    end,
                    [],
                    members0,
                  )
                in
                let members1 = List.reverse(acc) in
                let user_ids_for_notification = get_connected_user_ids_from_list(members1, -except user_id) in
                return(Some({user, user_ids_for_notification, InternalWaiting({ members = members1 })}))
            end

        | InternalPlaying(game_state) ->
            case find_user_seat(game_state, user_id) of
            | None ->
                return(None)

            | Some({seat, p0}) ->
                let Meta(meta) = game_state.meta in
                let players0 = meta.players in
                do Ok({}) <-
                  case p0.connection of
                  | Connected(_, _) ->
                      let _ =
                        assert Logger.info(
                          f'no timer (playing, seat: ~p, user_id: ~s)',
                          {seat, user_id}
                        )
                      in
                      return(Ok({}))
                  | Disconnected(timer) ->
                      cancel_disconnection_timer(timer, user_id, -log "playing")
                  end
                in
                do ws_mref <- WebSocketHandler.monitor(ws_proc) in
                let p1 = { p0 | connection = Connected(ws_proc, ws_mref) } in
                let players1 = Quad.update(seat, Some(p1), players0) in
                let user_ids_for_notification = get_connected_user_ids_from_quad(players1, -except user_id) in
                let game_state = { game_state | meta = Meta({ meta | players = players1 }) } in
                return(Some({p1.user, user_ids_for_notification, InternalPlaying(game_state)}))
            end
        end
      in
      case opt of
      | None ->
          GenServer.no_reply(state)

      | Some({user, user_ids_for_notification, room_state}) ->
          let connection = { user = user, is_connected = true } in
          do _ <- notify_for_each(user_ids_for_notification, [Models.NotifyConnection(connection)]) in
          let state =
            { state |
              room_state    = room_state,
              reversed_logs = Models.LogConnection(connection) :: state.reversed_logs,
            }
          in
          GenServer.no_reply(state)
      end

    val send_room_deletion_to_user_server<$m> : fun(user_id) -> [$m]unit = external 1 ```
      send_room_deletion_to_user_server(UserId) ->
          try
              _ = 'Tianjiupai.User':set_room(UserId, error),
              ok
          catch
              _:_ -> ok
          end.
    ```

    val handle_disconnection_timeout(user_id : user_id, state : state) = act
      let _ =
        assert Logger.info(
          f'disconnection timeout (user_id: ~s)',
          {user_id}
        )
      in
      let room_state0 = state.room_state in
      do opt <-
        case room_state0 of
        | InternalWaiting(waiting_state) ->
            let waiting_members0 = waiting_state.members in
            case List.filter(fun(w) -> Binary.equal(w.user.user_id, user_id) end, waiting_members0) of
            | [] ->
                return(None)

            | w :: _ ->
                do _ <- send_room_deletion_to_user_server(user_id) in
                let user = w.user in
                let waiting_members1 =
                  List.filter(
                    fun(w) -> Bool.not(Binary.equal(w.user.user_id, user_id)) end,
                    waiting_members0)
                in
                let user_ids_for_notification = get_connected_user_ids_from_list(waiting_members0, -except user_id) in
                do _ <- notify_for_each(user_ids_for_notification, [Models.NotifyExited(user)]) in
                return(Some({user, InternalWaiting({ waiting_state | members = waiting_members1 })}))
            end

        | InternalPlaying(game_state) ->
            case find_user_seat(game_state, user_id) of
            | None ->
                return(None)

            | Some({seat, player}) ->
                do _ <- send_room_deletion_to_user_server(user_id) in
                let Meta(meta0) = game_state.meta in
                let players0 = meta0.players in
                let user = player.user in
                let user_ids_for_notification = get_connected_user_ids(game_state, -except seat) in
                do _ <- notify_for_each(user_ids_for_notification, [Models.NotifyExited(user)]) in
                let players1 = Quad.update(seat, None, players0) in
                let game_state = { game_state | meta = Meta({ meta0 | players = players1 }) } in
                return(Some({user, InternalPlaying(game_state)}))
            end
        end
      in
      let state =
        case opt of
        | Some({user, room_state1}) ->
            { state |
              reversed_logs = Models.LogExited(user) :: state.reversed_logs,
              room_state    = room_state1,
            }

        | None ->
            state
        end
      in
      GenServer.no_reply(state)

    val update_sync(user_id : user_id, state : state) = act
      case state.room_state of
      | InternalWaiting(_) ->
          return(state)

      | InternalPlaying(game_state) ->
          case find_user_seat(game_state, user_id) of
          | None ->
              return(state)

          | Some({seat, _}) ->
              case game_state.sync of
              | WaitingInput ->
                  return(state)

              | WaitingSync(sync_quad) ->
                  let sync_quad = Quad.update(seat, true, sync_quad) in
                  case Quad.decompose(sync_quad) of
                  | {true, true, true, true} ->
                    /* If all the players are ready for the next step: */
                      let user_ids_for_notification = get_connected_user_ids(game_state, -except seat) in
                      do _ <- notify_for_each(user_ids_for_notification, [Models.NotifyNextStep]) in
                      let game_state = { game_state | sync = WaitingInput } in
                      return({ state | room_state = InternalPlaying(game_state) })

                  | _ ->
                      let game_state = { game_state | sync = WaitingSync(sync_quad) } in
                      return({ state | room_state = InternalPlaying(game_state) })
                  end
              end
          end
      end

    val handle_call(req, _, state) = act
      case req of
      | GetWholeState ->
          let whole_state = make_whole_room_state(state) in
          GenServer.reply(WholeState(whole_state), state)
      | GetPersonalState(user_id) ->
          do state <- update_sync(user_id, state) in
          let personal_state_opt = make_personal_state(state, user_id) in
          GenServer.reply(PersonalState(personal_state_opt), state)
      | SendChat(user, text) ->
          handle_send_chat(user, text, state)
      | Attend(user, ws_proc) ->
          handle_attend(user, ws_proc, state)
      | Exit(user_id) ->
          handle_exit(user_id, state)
      | Submit(user_id, cards) ->
          handle_submit(user_id, cards, state)
      end

    val handle_cast(msg, state) = act
      case msg of
      | Ack(user_id, snapshot_id) ->
          handle_ack(user_id, snapshot_id, state)

      | RequireNextInning(user_id, snapshot_id) ->
          handle_require_next_inning(user_id, snapshot_id, state)

      | SetConnection(user_id, ws_proc) ->
          handle_set_connection(user_id, ws_proc, state)
      end

    val handle_timeout(state) = act
      let _ = assert Logger.info(f'timeout (room_id: ~s)', {state.settings.room_id}) in
      GenServer.no_reply_and_stop(StopReason.normal(), state)

    val handle_down(mref, _, reason, state) = act
      case state.room_state of
      | InternalWaiting(waiting) ->
          let waiting_members0 = waiting.members in
          do {player_acc, log_acc} <-
            List.foldl_effect(
              fun({player_acc, log_acc}, player) -> act
                case player.connection of
                | Connected(_, mref_ws) ->
                    if MonitorRef.equal(mref_ws, mref) then
                      let user = player.user in
                      let user_id = user.user_id in
                      let _ =
                        assert Logger.info(
                          f'WebSocket connection closed (user_id: ~s, reason: ~p)',
                          {user_id, reason}
                        )
                      in
                      do Ok(timer) <- set_disconnection_timer(user_id, -log "waiting") in
                      let user_ids_for_notification = get_connected_user_ids_from_list(waiting_members0, -except user_id) in
                      let connection = { user = user, is_connected = false } in
                      do _ <- notify_for_each(user_ids_for_notification, [Models.NotifyConnection(connection)]) in
                      let player_acc = { player | connection = Disconnected(timer) } :: player_acc in
                      let log_acc = LogConnection(connection) :: log_acc in
                      return({player_acc, log_acc})
                    else
                      return({player :: player_acc, log_acc})

                | Disconnected(_) ->
                    return({player :: player_acc, log_acc})
                end
              end,
              {[], state.reversed_logs},
              waiting_members0)
          in
          let players = List.reverse(player_acc) in
          GenServer.no_reply(
            { state |
              reversed_logs = log_acc,
              room_state    = InternalWaiting({ members = players }),
            })

      | InternalPlaying(game_state) ->
          let Meta(meta) = game_state.meta in
          let players0 = meta.players in
          do {log_acc, players} <-
            Quad.map_fold_effect(
              fun(log_acc, player_opt) -> act
                case player_opt of
                | None ->
                    return({log_acc, None})

                | Some(player) ->
                    case player.connection of
                    | Connected(_, mref_ws) ->
                        if MonitorRef.equal(mref_ws, mref) then
                          let user = player.user in
                          let user_id = user.user_id in
                          let _ =
                            assert Logger.info(
                              f'WebSocket connection closed (user_id: ~s, reason: ~p)',
                              {user_id, reason}
                            )
                          in
                          do Ok(timer) <- set_disconnection_timer(player.user.user_id, -log "playing") in
                          let user_ids_for_notification = get_connected_user_ids_from_quad(players0, -except user_id) in
                          let connection = { user = user, is_connected = false } in
                          do _ <- notify_for_each(user_ids_for_notification, [Models.NotifyConnection(connection)]) in
                          let player = { player | connection = Disconnected(timer) } in
                          let log_acc = LogConnection(connection) :: log_acc in
                          return({log_acc, Some(player)})
                        else
                          return({log_acc, player_opt})

                    | Disconnected(_) ->
                        return({log_acc, player_opt})
                    end
                end
              end,
              state.reversed_logs,
              players0)
          in
          let game_state = { game_state | meta = Meta({ meta | players = players }) } in
          GenServer.no_reply(
            { state |
              reversed_logs = log_acc,
              room_state    = InternalPlaying(game_state),
            })
      end

    val handle_info(info, state) = act
      case info of
      | DisconnectionTimeout(user_id) ->
          handle_disconnection_timeout(user_id, state)

      | _ ->
          let _ = assert Logger.warning(f'unexpected info (info: ~p, state: ~p)', {info, state}) in
          GenServer.no_reply(state)
      end

    val terminate(reason, state) = act
      let _ = assert Logger.info(f'terminate (reason: ~p, room_id: ~s)', {reason, state.settings.room_id}) in
      return({})
  end

  module Impl = GenServer.Make(Callback)

  type info = Callback.info

  type proc = Impl.proc

  val monitor(room_id : room_id) = act
    do proc_opt <- Impl.where_is_global(room_id) in
    case proc_opt of
    | Some(proc) -> do mref <- MonitorRef.monitor(Impl.as_pid(proc)) in return(Some(mref))
    | None       -> return(None)
    end

  val start_link<$a>(room_id : room_id, room_name : binary) : [$a]result<proc, GenServer.start_link_error> = act
    Impl.start_link_name({room_id, room_name}, -name Global(room_id))

  val as_pid(proc) =
    Impl.as_pid(proc)

  val from_pid(proc) =
    Impl.from_pid(proc)

  val call<$a, $ret>(
    room_id : room_id,
    req     : Callback.request,
    f       : fun(Callback.response) -> [$a]option<$ret>
  ) : [$a]option<$ret> = act
    do proc_opt <- Impl.where_is_global(room_id) in
    case proc_opt of
    | None ->
        return(None)

    | Some(proc) ->
        do resp_result <- Impl.call(proc, req) in
        case resp_result of
        | Ok(resp) ->
            f(resp)

        | Error(err) ->
            let _ =
              assert Logger.warning(
                f'call failed (room_id: ~s, req: ~p, proc: ~p, error: ~p)',
                {room_id, req, proc, err},
              )
            in
            return(None)
        end
    end

  val get_whole_state<$a>(room_id : room_id) : [$a]option<room_summary> = act
    call(room_id, Callback.GetWholeState,
      fun(Callback.WholeState(whole_state)) -> act return(Some(whole_state)) end)

  val get_whole_state_by_proc<$a>(proc : proc) : [$a]option<room_summary> = act
    do resp_result <- Impl.call(proc, Callback.GetWholeState) in
    case resp_result of
    | Ok(Callback.WholeState(whole_state)) ->
        return(Some(whole_state))

    | Error(err) ->
        let _ =
          assert Logger.warning(
            f'call failed (proc: ~p, error: ~p)',
            {proc, err},
          )
        in
        return(None)
    end

  val get_personal_state<$a>(room_id : room_id, user_id : user_id) : [$a]option<personal_state> = act
    call(room_id, Callback.GetPersonalState(user_id),
      fun(Callback.PersonalState(personal_state_opt)) -> act return(personal_state_opt) end)

  val send_chat<$a>(room_id : room_id, user : user, text : binary) : [$a]option<unit> = act
    call(room_id, Callback.SendChat(user, text),
      fun(Callback.ChatSent) -> act return(Some({})) end)

  val attend<$a>(room_id : room_id, user : user, ws_proc : WebSocketHandler.proc) : [$a]option<personal_state> = act
    call(room_id, Callback.Attend(user, ws_proc),
      fun(Callback.Attended(game_state_opt)) -> act return(game_state_opt) end)

  val exit<$a>(room_id, user_id) : [$a]option<unit> = act
    call(room_id, Callback.Exit(user_id), fun(Callback.Exited(success)) -> act
      if success then return(Some({})) else return(None)
    end)

  val submit<$a>(room_id, user_id, cards) : [$a]option<{observable_game_state, option<last>}> = act
    call(room_id, Callback.Submit(user_id, cards),
      fun(Callback.SubmissionDone(v)) -> act return(v) end)

  val ack<$a>(room_id, user_id, snapshot_id) : [$a]unit = act
    do proc_opt <- Impl.where_is_global(room_id) in
    case proc_opt of
    | None       -> return({})
    | Some(proc) -> Impl.cast(proc, Callback.Ack(user_id, snapshot_id))
    end

  val require_next_inning<$a>(room_id, user_id, snapshot_id) : [$a]unit = act
    do proc_opt <- Impl.where_is_global(room_id) in
    case proc_opt of
    | None       -> return({})
    | Some(proc) -> Impl.cast(proc, Callback.RequireNextInning(user_id, snapshot_id))
    end

  val set_connection(room_id, user_id, ws_proc) = act
    do proc_opt <- Impl.where_is_global(room_id) in
    case proc_opt of
    | None       -> return({})
    | Some(proc) -> Impl.cast(proc, Callback.SetConnection(user_id, ws_proc))
    end

end
