import Quad
import Card
import SnapshotId
import Types
import Inning

module RoomServer :> sig
  open Stdlib
  open Types

  type info :: o
  type proc :: o
  val start_link<$a> : fun(room_id, binary) -> [$a]result<proc, GenServer.start_link_error>
  val as_pid : fun(proc) -> pid<info>
  val from_pid : fun(pid<info>) -> proc
  val monitor<$a> : fun(room_id) -> [$a]option<RawValue.t>

  val get_whole_state<$a> : fun(room_id) -> [$a]option<whole_room_state>
  val get_whole_state_by_proc<$a> : fun(proc) -> [$a]option<whole_room_state>
  val get_personal_state<$a> : fun(room_id, user_id) -> [$a]option<personal_room_state>

  val send_chat<$a> : fun(room_id, user, binary) -> [$a]option<unit>
  val attend<$a> : fun(room_id, user) -> [$a]option<personal_room_state>
  val exit<$a> : fun(room_id, user_id) -> [$a]option<unit>
  val submit<$a> : fun(room_id, user_id, list<Card.t>) -> [$a]option<{observable_game_state, option<table_state>}>
  val ack<$a> : fun(room_id, user_id, snapshot_id) -> [$a]unit

end = struct
  open Stdlib
  open Types

  val todo<$a, $b> : fun($a) -> $b = external 1 ```
    todo(X) ->
      erlang:error({todo, X}).
  ```

  type settings = {
    room_id   : room_id,
    room_name : binary,
  }

  type waiting_state = {
    members : list<user>,
  }

  type sync =
    | WaitingInput
    | WaitingSync(Quad.t<bool>)

  type whole_inning =
    | DuringInning(Inning.t)
    | InningEnd(Quad.t<list<Card.t>>)

  type whole_game_state = {
    meta        : game_meta,
    inning      : whole_inning,
    snapshot_id : snapshot_id,
    sync        : sync, /* Tracks whether each player is ready for the next step. */
  }

  type internal_room_state =
    | InternalWaiting(waiting_state)
    | InternalPlaying(whole_game_state)

  type request_impl =
    | GetWholeState
    | GetPersonalState(user_id)
    | SendChat(user, binary)
    | Attend(user)
    | Exit(user_id)
    | Submit(user_id, list<Card.t>)

  type response_impl =
    | WholeState(whole_room_state)
    | PersonalState(option<personal_room_state>)
    | ChatSent
    | Attended(option<personal_room_state>)
    | Exited(bool)
    | SubmissionDone(option<{observable_game_state, option<table_state>}>)

  module Callback = struct
    type init_arg = {room_id, binary}

    type request = request_impl

    type response = response_impl

    type cast_message =
      | Ack(user_id, snapshot_id)

    type info =
      | DummyInfo

    type state = {
      settings      : settings,
      reversed_logs : list<log>,
      room_state    : internal_room_state,
    }

    type global = room_id

    type stop_reason = RawValue.t

    val init(init_arg) = act
      let {room_id, room_name} = init_arg in
      let settings = {room_id = room_id, room_name = room_name} in
      GenServer.init_ok({
        settings      = settings,
        reversed_logs = [],
        room_state    = InternalWaiting({members = []})
      })

    val get_members_from_state(room_state : internal_room_state) : {bool, list<user>} =
      case room_state of
      | InternalWaiting(waiting_state) ->
          {false, waiting_state.members}

      | InternalPlaying(whole_game_state) ->
          let game_players = Quad.to_list(whole_game_state.meta.players) in
          let members = List.map(fun(p) -> p.user end, game_players) in
          {true, members}
      end

    val make_whole_room_state(state : state) : whole_room_state =
      let settings = state.settings in
      let {is_playing, members} = get_members_from_state(state.room_state) in
      {
        room_id    = settings.room_id,
        room_name  = settings.room_name,
        is_playing = is_playing,
        members    = members,
      }

    val find_user_seat(game_state : whole_game_state, user_id : user_id) =
      let opt = Quad.find(fun(p) -> Binary.equal(p.user.user_id, user_id) end, game_state.meta.players) in
      Option.map(
        fun(pair) ->
          let {seat, _} = pair in
          seat
        end,
        opt)

    val the_other_seats(seat) =
      case seat of
      | Quad.Seat0 -> [Quad.Seat1, Quad.Seat2, Quad.Seat3]
      | Quad.Seat1 -> [Quad.Seat2, Quad.Seat3, Quad.Seat0]
      | Quad.Seat2 -> [Quad.Seat3, Quad.Seat0, Quad.Seat1]
      | Quad.Seat3 -> [Quad.Seat0, Quad.Seat1, Quad.Seat2]
      end

    val the_other_players(game_state : whole_game_state, seat : Quad.seat) : list<user_id> =
      let {u0, u1, u2, u3} = Quad.map(fun(p) -> p.user.user_id end, game_state.meta.players) in
      case seat of
      | Quad.Seat0 -> [u1, u2, u3]
      | Quad.Seat1 -> [u2, u3, u0]
      | Quad.Seat2 -> [u3, u0, u1]
      | Quad.Seat3 -> [u0, u1, u2]
      end

    val make_observable_game_state(game_state : whole_game_state, user_id : user_id) : option<observable_game_state> =
      case find_user_seat(game_state, user_id) of
      | None ->
          None

      | Some(seat) ->
          let synchronizing =
            case game_state.sync of
            | WaitingInput   -> false
            | WaitingSync(_) -> true
            end
          in
          let observable_inning =
            case game_state.inning of
            | DuringInning(inning)  -> ObservableDuringInning(Inning.observe(seat, inning))
            | InningEnd(gains_quad) -> ObservableInningEnd(gains_quad)
            end
          in
          Some({
            meta              = game_state.meta,
            observable_inning = observable_inning,
            synchronizing     = synchronizing,
            snapshot_id       = game_state.snapshot_id,
          })
      end

    val make_observable(room_state : internal_room_state, user_id : user_id) : option<observable_room_state> =
      case room_state of
      | InternalWaiting(waiting_state) ->
          Some(Waiting(waiting_state.members))

      | InternalPlaying(game_state) ->
          Option.map(fun(obs) -> Playing(obs) end, make_observable_game_state(game_state, user_id))
      end

    val make_personal_room_state(state : state, user_id : user_id) : option<personal_room_state> =
      let settings = state.settings in
      case make_observable(state.room_state, user_id) of
      | None ->
          None

      | Some(observable) ->
          Some({
            room_id    = settings.room_id,
            room_name  = settings.room_name,
            logs       = List.reverse(state.reversed_logs),
            observable = observable,
          })
      end

    val make_initial_sync() =
      {false, false, false, false}

    val notify<$a> : fun(user_id, list<notification>) -> [$a]unit = external 2 ```
      notify(UserId, Notifications) ->
          case tianjiupai_websocket:notify(UserId, Notifications) of
              ok ->
                  ok;
              {error, Reason} ->
                  io:format("~p, notify_log failed (reason: ~p, to: ~p, notifications: ~p)",
                      [?MODULE, Reason, UserId, Notifications]),
                  ok
          end.
    ```

    val notify_for_each<$a>(user_ids : list<user_id>, logs : list<notification>) : [$a]unit = act
      List.for_each(fun(user_id) -> act notify(user_id, logs) end, user_ids)

    val handle_send_chat(user : user, text : binary, state : state) = act
      let user_id = user.user_id in
      let {_, members} = get_members_from_state(state.room_state) in
      do dummy <-
        let user_ids = List.map(fun (u) -> u.user_id end, members) in
        notify_for_each(user_ids, [NotifyComment(user, text)])
      in
      GenServer.reply(ChatSent, { state | reversed_logs = LogComment(user, text) :: state.reversed_logs })

    val handle_attend(user : user, state : state) = act
      let user_id = user.user_id in
      case state.room_state of
      | InternalPlaying(_) ->
          GenServer.reply(Attended(None), state)

      | InternalWaiting(waiting_state) ->
          let members = waiting_state.members in
          if List.any(fun(u) -> Binary.equal(u.user_id, user_id) end, members) then
            let Some(personal_state) = make_personal_room_state(state, user_id) in
            GenServer.reply(Attended(Some(personal_state)), state)
          else
            let log_enter = LogEntered(user) in
            let notif_enter = NotifyEntered(user) in
            case members of
            | u0 :: u1 :: u2 :: _ ->
                let player_quad =
                  let player0 = { user = u0, score = 0 } in
                  let player1 = { user = u1, score = 0 } in
                  let player2 = { user = u2, score = 0 } in
                  let player3 = { user = user, score = 0 } in
                  {player0, player1, player2, player3}
                in
                let parent_seat = Quad.Seat0 in
                let game_meta =
                  {
                    inning_index     = 0,
                    num_consecutives = 1,
                    parent_seat      = parent_seat,
                    players          = player_quad,
                  }
                in
                do snapshot_id <- SnapshotId.generate() in
                let inning = Inning.start(parent_seat) in
                let game_state =
                  {
                    meta        = game_meta,
                    inning      = DuringInning(inning),
                    snapshot_id = snapshot_id,
                    sync        = WaitingSync(make_initial_sync()),
                  }
                in
                let user_id0 = u0.user_id in
                let user_id1 = u1.user_id in
                let user_id2 = u2.user_id in
                let Some(obs0) = make_observable_game_state(game_state, user_id0) in
                let Some(obs1) = make_observable_game_state(game_state, user_id1) in
                let Some(obs2) = make_observable_game_state(game_state, user_id2) in
                do dummy <- notify(user_id0, [notif_enter, NotifyGameStart(obs0)]) in
                do dummy <- notify(user_id1, [notif_enter, NotifyGameStart(obs1)]) in
                do dummy <- notify(user_id2, [notif_enter, NotifyGameStart(obs2)]) in
                let state =
                  { state |
                    room_state    = InternalPlaying(game_state),
                    reversed_logs = LogGameStart :: log_enter :: state.reversed_logs,
                  }
                in
                let Some(personal_state) = make_personal_room_state(state, user_id) in
                GenServer.reply(Attended(Some(personal_state)), state)

            | _ ->
                let waiting_state = { waiting_state | members = List.append(members, [user]) } in
                do dummy <- notify_for_each(List.map(fun(u) -> u.user_id end, members), [notif_enter]) in
                let state =
                  { state |
                    room_state    = InternalWaiting(waiting_state),
                    reversed_logs = log_enter :: state.reversed_logs,
                  }
                in
                let Some(personal_state) = make_personal_room_state(state, user_id) in
                GenServer.reply(Attended(Some(personal_state)), state)
            end
      end

    val handle_exit(user_id : user_id, state : state) = act
      case state.room_state of
      | InternalPlaying(_) ->
          GenServer.reply(Exited(false), state)

      | InternalWaiting(waiting_state) ->
          let members =
            List.filter(
              fun(u) -> Bool.not(Binary.equal(u.user_id, user_id)) end,
              waiting_state.members)
          in
          let room_state = InternalWaiting({ waiting_state | members = members }) in
          GenServer.reply(Exited(true), { state | room_state = room_state })
      end

    val make_winner_diff(losers) =
      let loser_diff_sum =
        List.foldl(
          fun(acc, loser) -> let {_, loser_diff} = loser in acc + loser_diff end,
          0,
          losers)
      in
      0 - loser_diff_sum

    val update_score(players, updates) =
      List.foldl(
        fun(players, update) ->
          let {seat, diff} = update in
          let player = Quad.access(seat, players) in
          Quad.update(seat, { player | score = player.score + diff }, players)
        end,
        players,
        updates)

    val deal_with_inning_end(game_meta, winner_seat, gains_quad) : game_meta =
      let loser_seats = the_other_seats(winner_seat) in
      let num_consecutives = game_meta.num_consecutives in
      let parent_seat = game_meta.parent_seat in
      if Quad.seat_equal(winner_seat, parent_seat) then
      /* If the parent wins: */
        let losers =
          List.map(
            fun(loser_seat) ->
              let num_gains = List.length(Quad.access(loser_seat, gains_quad)) in
              let loser_diff =
                if num_gains == 0 then
                  0 - 5 * (num_consecutives + 1)
                else
                  (num_gains - 4) * (num_consecutives + 1)
              in
              {loser_seat, loser_diff}
            end,
            loser_seats)
        in
        let winner_diff = make_winner_diff(losers) in
        let players = update_score(game_meta.players, {winner_seat, winner_diff} :: losers) in
        {
          inning_index     = game_meta.inning_index,
          num_consecutives = num_consecutives + 1,
          parent_seat      = parent_seat,
          players          = players,
        }
      else
        let losers =
          List.map(
            fun(loser_seat) ->
              let num_gains = List.length(Quad.access(loser_seat, gains_quad)) in
              let loser_diff =
                let coeff =
                  if Quad.seat_equal(loser_seat, parent_seat) then
                    num_consecutives + 1
                  else
                    1
                in
                if num_gains == 0 then
                  0 - 5 * coeff
                else
                  (num_gains - 4) * coeff
              in
              {loser_seat, loser_diff}
            end,
            loser_seats)
        in
        let winner_diff = make_winner_diff(losers) in
        let players = update_score(game_meta.players, {winner_seat, winner_diff} :: losers) in
        {
          inning_index     = game_meta.inning_index + 1,
          num_consecutives = 1,
          parent_seat      = winner_seat,
          players          = players,
        }

    val handle_submit(user_id : user_id, cards : list<Card.t>, state : state) = act
      do opt <-
        case state.room_state of
        | InternalWaiting(_) ->
            return(None)

        | InternalPlaying(game_state) ->
            case find_user_seat(game_state, user_id) of
            | None ->
                return(None)

            | Some(seat) ->
                case game_state.inning of
                | InningEnd(_) ->
                    return(None)

                | DuringInning(inning) ->
                    case Inning.submit(seat, cards, inning) of
                    | None ->
                        return(None)

                    | Some({submit_result, is_front}) ->
                        do snapshot_id <- SnapshotId.generate() in
                        let game_meta = game_state.meta in
                        let {game_state, last_table_opt} =
                          case submit_result of
                          | Inning.Continues(inning) ->
                              {
                                {
                                  meta        = game_meta,
                                  inning      = DuringInning(inning),
                                  snapshot_id = snapshot_id,
                                  sync        = WaitingSync(make_initial_sync()),
                                },
                                None
                              }

                          | Inning.WinsTrick(winner_seat, last_table, inning) ->
                              {
                                {
                                  meta        = game_meta,
                                  inning      = DuringInning(inning),
                                  snapshot_id = snapshot_id,
                                  sync        = WaitingSync(make_initial_sync()),
                                },
                                Some(last_table)
                              }

                          | Inning.WinsInning(winner_seat, last_table, gains_quad) ->
                              {
                                {
                                  meta        = deal_with_inning_end(game_meta, winner_seat, gains_quad),
                                  inning      = InningEnd(gains_quad),
                                  snapshot_id = snapshot_id,
                                  sync        = WaitingSync(make_initial_sync()),
                                },
                                Some(last_table)
                              }
                          end
                        in
                        let card_opts =
                          if is_front then
                            List.map(fun(card) -> Some(card) end, cards)
                          else
                            List.map(fun(card) -> None end, cards)
                        in
                        do dummy <-
                          List.for_each(
                            fun(u) -> act
                              let Some(obs) = make_observable_game_state(game_state, u) in
                              let submission =
                                {
                                  seat       = seat,
                                  submitted  = card_opts,
                                  new_state  = obs,
                                  trick_last = last_table_opt,
                                }
                              in
                              notify(u, [NotifySubmission(submission)])
                            end,
                            the_other_players(game_state, seat)
                          )
                        in
                        let Some(obs) = make_observable_game_state(game_state, user_id) in
                        return(Some({obs, last_table_opt, game_state}))
                    end
                end
            end
        end
      in
      case opt of
      | None ->
          GenServer.reply(SubmissionDone(None), state)

      | Some({obs, last_table_opt, game_state}) ->
          GenServer.reply(
            SubmissionDone(Some({obs, last_table_opt})),
            { state | room_state = InternalPlaying(game_state) },
          )
      end

    val handle_ack(user_id : user_id, snapshot_id : snapshot_id, state : state) = act
      do opt <-
        case state.room_state of
        | InternalWaiting(_) ->
            return(None)

        | InternalPlaying(game_state) ->
            case find_user_seat(game_state, user_id) of
            | None ->
                return(None)

            | Some(seat) ->
                if SnapshotId.equal(snapshot_id, game_state.snapshot_id) then
                  case game_state.sync of
                  | WaitingSync(sync_quad) ->
                      let sync_quad = Quad.update(seat, true, sync_quad) in
                      let _ = print_debug({"update sync", snapshot_id, game_state.snapshot_id, sync_quad}) in /* temporary */
                      case sync_quad of
                      | {true, true, true, true} ->
                        /* If all the players are ready for the next step: */
                          let user_ids = the_other_players(game_state, seat) in
                          do dummy <- notify_for_each(user_id :: user_ids, [NotifyNextStep]) in
                          let game_state = { game_state | sync = WaitingInput } in
                          return(Some(game_state))

                      | _ ->
                          let game_state = { game_state | sync = WaitingSync(sync_quad) } in
                          return(Some(game_state))
                      end
                  | WaitingInput ->
                     let _ = print_debug({"waiting input", snapshot_id, game_state.snapshot_id}) in
                      return(None)
                  end
                else
                  let _ = print_debug({"snapshot mismatch", snapshot_id, game_state.snapshot_id}) in
                  return(None)
            end
        end
      in
      case opt of
      | None             -> GenServer.no_reply(state)
      | Some(game_state) -> GenServer.no_reply({ state | room_state = InternalPlaying(game_state) })
      end

    val update_sync(user_id : user_id, state : state) = act
      case state.room_state of
      | InternalWaiting(_) ->
          return(state)

      | InternalPlaying(game_state) ->
          case find_user_seat(game_state, user_id) of
          | None ->
              return(state)

          | Some(seat) ->
              case game_state.sync of
              | WaitingInput ->
                  return(state)

              | WaitingSync(sync_quad) ->
                  let sync_quad = Quad.update(seat, true, sync_quad) in
                  case sync_quad of
                  | {true, true, true, true} ->
                    /* If all the players are ready for the next step: */
                      let user_ids = the_other_players(game_state, seat) in
                      do dummy <- notify_for_each(user_ids, [NotifyNextStep]) in
                      let game_state = { game_state | sync = WaitingInput } in
                      return({ state | room_state = InternalPlaying(game_state) })

                  | _ ->
                      let game_state = { game_state | sync = WaitingSync(sync_quad) } in
                      return({ state | room_state = InternalPlaying(game_state) })
                  end
              end
          end
      end

    val handle_call(req, from, state) = act
      case req of
      | GetWholeState ->
          let whole_state = make_whole_room_state(state) in
          GenServer.reply(WholeState(whole_state), state)
      | GetPersonalState(user_id) ->
          do state <- update_sync(user_id, state) in
          let personal_state_opt = make_personal_room_state(state, user_id) in
          GenServer.reply(PersonalState(personal_state_opt), state)
      | SendChat(user, text) ->
          handle_send_chat(user, text, state)
      | Attend(user) ->
          handle_attend(user, state)
      | Exit(user_id) ->
          handle_exit(user_id, state)
      | Submit(user_id, cards) ->
          handle_submit(user_id, cards, state)
      end

    val handle_cast(msg, state) = act
      case msg of
      | Ack(user_id, snapshot_id) ->
          handle_ack(user_id, snapshot_id, state)
      end

    val handle_info(info, state) = act
      let _ = print_debug({"unexpected info", info}) in
      GenServer.no_reply(state)

    val terminate(state) = act
      let _ = print_debug({"terminate", state}) in
      return({})
  end

  module Impl = GenServer.Make(Callback)

  type info = Callback.info

  type proc = Impl.proc

  val monitor_impl<$a> : fun(pack sig end, room_id) -> [$a]option<RawValue.t> = external 2 ```
    monitor_impl(Impl, RoomId) ->
        case Impl:where_is_global(RoomId) of
            error     -> error;
            {ok, Pid} -> {ok, erlang:monitor(process, Pid)}
        end.
  ```

  val monitor(room_id) = act
    monitor_impl(pack Impl : sig end, room_id)

  val start_link<$a>(room_id : room_id, room_name : binary) : [$a]result<proc, GenServer.start_link_error> = act
    Impl.start_link_name({room_id, room_name}, -name Global(room_id))

  val as_pid(proc) =
    Impl.as_pid(proc)

  val from_pid(proc) =
    Impl.from_pid(proc)

  val call<$a, $ret>(
    room_id : room_id,
    req     : request_impl,
    f       : fun(response_impl) -> [$a]option<$ret>
  ) : [$a]option<$ret> = act
    do proc_opt <- Impl.where_is_global(room_id) in
    case proc_opt of
    | None ->
        return(None)

    | Some(proc) ->
        do resp <- Impl.call(proc, req) in
        f(resp)
    end

  val get_whole_state<$a>(room_id : room_id) : [$a]option<whole_room_state> = act
    call(room_id, GetWholeState, fun(resp) -> act
      case resp of
      | WholeState(whole_state) -> return(Some(whole_state))
      end
    end)

  val get_whole_state_by_proc<$a>(proc : proc) : [$a]option<whole_room_state> = act
    do resp <- Impl.call(proc, GetWholeState) in
    case resp of
    | WholeState(whole_state) -> return(Some(whole_state))
    end

  val get_personal_state<$a>(room_id : room_id, user_id : user_id) : [$a]option<personal_room_state> = act
    call(room_id, GetPersonalState(user_id), fun(resp) -> act
      case resp of
      | PersonalState(personal_state_opt) -> return(personal_state_opt)
      end
    end)

  val send_chat<$a>(room_id : room_id, user : user, text : binary) : [$a]option<unit> = act
    call(room_id, SendChat(user, text), fun(resp) -> act
      case resp of
      | ChatSent -> return(Some({}))
      end
    end)

  val attend<$a>(room_id : room_id, user : user) : [$a]option<personal_room_state> = act
    call(room_id, Attend(user), fun(resp) -> act
      case resp of
      | Attended(game_state_opt) -> return(game_state_opt)
      end
    end)

  val exit<$a>(room_id, user_id) : [$a]option<unit> = act
    call(room_id, Exit(user_id), fun(resp) -> act
      case resp of
      | Exited(false) -> return(None)
      | Exited(true)  -> return(Some({}))
      end
    end)

  val submit<$a>(room_id, user_id, cards) : [$a]option<{observable_game_state, option<table_state>}> = act
    call(room_id, Submit(user_id, cards), fun(resp) -> act
      case resp of
      | SubmissionDone(v) -> return(v)
      end
    end)

  val ack<$a>(room_id, user_id, snapshot_id) : [$a]unit = act
    do proc_opt <- Impl.where_is_global(room_id) in
    case proc_opt of
    | None ->
        return({})

    | Some(proc) ->
        Impl.cast(proc, Callback.Ack(user_id, snapshot_id))
    end

end
